# Project Architecture and Guidelines

## Overview
This document outlines the structure, architecture, and philosophies of the AlgoTradingModels project. It aims to prevent duplicate files, ensure clear separation of concerns, and maintain a clean, maintainable codebase.

## Project Structure
```
AlgoTradingModels/
├── src/                    # Source code
│   ├── data/              # Data fetching, processing, and caching
│   │   ├── vendors/       # Data providers (Polygon, Yahoo Finance)
│   │   └── data_loader.py # Data loading and caching
│   ├── execution/         # Trade execution and portfolio management
│   │   ├── portfolio_manager.py
│   │   ├── trade_executor.py
│   │   └── signal_aggregation/  # Signal aggregation strategies
│   ├── features/          # Feature engineering
│   │   ├── feature_store.py
│   │   └── technical_indicators.py
│   ├── strategies/        # Trading strategies
│   │   ├── SingleStock/   # Single stock strategies
│   │   └── portfolio/     # Portfolio strategies
│   ├── visualization/     # Results visualization
│   └── run_trading_system.py  # Main system driver
├── tests/                 # Unit and integration tests
├── logs/                  # Logs and results
├── setup.py              # Package setup
└── README.md             # Project documentation
```

## Core Components

### 1. Data Layer
- Responsible for data fetching, processing, and caching
- Supports multiple data providers (Polygon, Yahoo Finance)
- Implements data caching for performance
- Handles data preprocessing and validation

### 2. Feature Layer
- Manages feature engineering and technical indicators
- Implements feature caching through FeatureStore
- Ensures consistent feature calculation across strategies
- Supports feature versioning and validation

### 3. Strategy Layer
- Implements trading strategies (SingleStock and Portfolio)
- Generates trading signals based on features
- Supports multiple strategy types:
  - Moving Average Crossover
  - Random Forest ML-based
  - Portfolio-based strategies

### 4. Execution Layer
- Manages portfolio state and positions
- Handles trade execution and risk management
- Implements signal aggregation for multi-strategy portfolios
- Provides performance metrics and analysis

## Key Philosophies

### 1. Single Responsibility Principle
- Each module or class should have only one reason to change
- Clear separation between data, features, strategies, and execution
- Avoid mixing concerns across layers

### 2. Feature Engineering
- All features MUST be generated by the feature engineering store
- Strategies SHOULD NOT generate their own features
- Features should be:
  - Cached for performance
  - Reusable across strategies
  - Consistently calculated
  - Version controlled

### 3. Strategy Design
- Strategies should focus on:
  - Signal generation
  - Decision making
  - Risk management
- Strategies should NOT:
  - Generate features
  - Handle data fetching
  - Manage portfolio state

### 4. Portfolio Management
- Portfolio state is managed by PortfolioManager
- Strategies should not maintain portfolio state
- All trades must go through PortfolioManager
- Support for multi-strategy portfolios with signal aggregation

### 5. Testing and Documentation
- Write unit tests for all modules and functions
- Document code with clear docstrings and comments
- Use pytest markers for fast/slow tests
- Maintain test coverage above 80%

### 6. Version Control
- Use Git for version control
- Commit changes with clear, descriptive messages
- Follow conventional commit format
- Avoid committing unnecessary files

## Testing Guidelines
- All test files should be placed in the `tests/` directory
- Use pytest for testing
- Mark slow tests with `@pytest.mark.slow`
- Maintain test coverage reports
- Run tests in CI/CD pipeline

## Configuration Guidelines
- Use configuration files for strategy parameters
- Support command-line arguments for runtime configuration
- Use environment variables for sensitive data
- Implement configuration validation

## Performance Guidelines
- Cache expensive computations
- Use efficient data structures
- Implement proper error handling
- Monitor memory usage
- Profile code for bottlenecks

## Service-Oriented Architecture (SOA) Guidelines

### 1. Service Independence
- Each strategy and agent should be designed as a potential standalone service
- Minimize dependencies between components
- Use clean interfaces for inter-service communication
- Design for eventual service extraction

### 2. Interface Design
- Define clear service boundaries
- Use well-documented APIs for inter-service communication
- Implement versioning for service interfaces
- Design interfaces to be technology-agnostic

### 3. Service Components
- **Strategy Services**
  - Single stock trading strategies
  - Portfolio management strategies
  - Signal generation services
  - Each strategy should be independently deployable

- **Data Services**
  - Market data providers
  - Feature engineering services
  - Data caching and storage
  - Historical data management

- **Execution Services**
  - Trade execution
  - Order management
  - Position tracking
  - Risk management

- **Aggregation Services**
  - Signal aggregation
  - Portfolio aggregation
  - Performance metrics aggregation

### 4. Service Communication
- Use message queues for asynchronous communication
- Implement event-driven architecture
- Design for eventual consistency
- Handle service failures gracefully

### 5. Data Management
- Each service should own its data
- Implement data versioning
- Design for data consistency across services
- Use appropriate data storage solutions per service

### 6. Deployment Considerations
- Design for containerization
- Implement health checks
- Use service discovery
- Support horizontal scaling
- Implement circuit breakers

### 7. Service Extraction Strategy
- Identify service boundaries
- Plan for gradual extraction
- Maintain backward compatibility
- Implement feature flags for smooth transition

## Implementation Guidelines for Service Extraction

### 1. Current Implementation
- Keep current monolithic structure
- Design components as if they were services
- Use dependency injection
- Implement interface-based design

### 2. Future Service Extraction
- Plan for service boundaries
- Design for API-first approach
- Implement service discovery
- Prepare for distributed deployment

### 3. Interface Examples
```python
# Strategy Service Interface
class StrategyService:
    def generate_signals(self, data: MarketData) -> List[Signal]:
        pass

    def update_state(self, new_data: MarketData) -> None:
        pass

# Portfolio Service Interface
class PortfolioService:
    def update_positions(self, trades: List[Trade]) -> PortfolioState:
        pass

    def calculate_metrics(self) -> PortfolioMetrics:
        pass

# Signal Aggregation Service Interface
class SignalAggregationService:
    def aggregate_signals(self, signals: List[Signal]) -> AggregatedSignal:
        pass

    def update_weights(self, new_weights: Dict[str, float]) -> None:
        pass
```

### 4. Service Dependencies
- Minimize direct dependencies
- Use dependency injection
- Implement service locator pattern
- Design for loose coupling

### 5. Error Handling
- Implement circuit breakers
- Use retry mechanisms
- Handle partial failures
- Implement fallback strategies

### 6. Monitoring and Logging
- Implement distributed tracing
- Use structured logging
- Monitor service health
- Track performance metrics

## Conclusion
Following these guidelines will help maintain a clean, maintainable, and scalable codebase. If you have any questions or suggestions, please raise them in the project discussions.

# Algorithmic Trading System Architecture

## Core Principles

### 1. Feature Engineering
- All features MUST be generated by the feature engineering store
- Strategies SHOULD NOT generate their own features
- Features should be:
  - Cached for performance
  - Reusable across strategies
  - Consistently calculated
  - Version controlled

### 2. Strategy Design
- Strategies should focus on:
  - Signal generation
  - Decision making
  - Risk management
- Strategies should NOT:
  - Generate features
  - Handle data fetching
  - Manage portfolio state

### 3. Portfolio Management
- Portfolio state is managed by PortfolioManager
- Strategies should not maintain portfolio state
- All trades must go through PortfolioManager

### 4. Trade Execution
- TradeDecider handles all trade decisions
- Strategies provide signals only
- TradeDecider applies constraints and risk management

## Directory Structure
```
src/
├── execution/           # Trade execution and portfolio management
├── features/           # Feature engineering and storage
├── strategies/         # Trading strategies
│   ├── base_strategy.py
│   └── SingleStock/    # Single stock strategies
└── run_trading_system.py  # Main driver file
```

## Strategy Interface
All strategies must:
1. Inherit from BaseStrategy
2. Use features from feature store
3. Generate standardized signals
4. Not maintain state (except for model parameters)

## Feature Store Interface
Feature store must:
1. Cache calculated features
2. Provide consistent feature calculation
3. Support feature versioning
4. Handle data preprocessing 

## Recent Update
- The driver file is now `run_trading_system.py`. 