# Project Architecture and Guidelines

## Overview
This document outlines the structure, architecture, and philosophies of the AlgoTradingModels project. It aims to prevent duplicate files, ensure clear separation of concerns, and maintain a clean, maintainable codebase.

## Project Structure
```
AlgoTradingModels/
├── src/                    # Source code
│   ├── data/               # Data fetching, processing, and caching
│   │   ├── vendors/        # Data providers (e.g., Polygon, Yahoo Finance)
│   │   └── feature_store.py # Feature caching and retrieval
│   ├── features/           # Feature engineering and technical indicators
│   ├── strategies/         # Trading strategies
│   │   └── SingleStock/    # Single stock strategy implementation
│   ├── helpers/            # Utility functions and helpers
│   └── scripts/            # Executable scripts (e.g., run_strategy.py)
├── tests/                  # Unit and integration tests
├── logs/                   # Logs and results
├── setup.py                # Package setup
└── README.md               # Project documentation
```

## Key Philosophies

### 1. **Single Responsibility Principle**
- Each module or class should have only one reason to change.
- Avoid merging different concerns in a single layer (e.g., data fetching, feature engineering, and strategy logic should be separate).

### 2. **Avoid Duplicate Files**
- Do not create duplicate files. If a file exists in one location, do not create it elsewhere.
- Use relative imports to reference modules within the project.

### 3. **Clear Separation of Concerns**
- **Data Layer**: Responsible for fetching, processing, and caching data. Do not mix data fetching with feature engineering or strategy logic.
- **Feature Layer**: Focus on feature engineering and technical indicators. Do not include data fetching or strategy logic here.
- **Strategy Layer**: Implement trading strategies. Do not include data fetching or feature engineering here.
- **Helper Layer**: Provide utility functions and helpers. Do not include business logic here.

### 4. **Consistent Naming and Structure**
- Use consistent naming conventions (e.g., snake_case for files and functions, CamelCase for classes).
- Follow the project structure outlined above. Do not create files or directories outside this structure.

### 5. **Testing and Documentation**
- Write unit tests for all modules and functions.
- Document code clearly, including docstrings and comments where necessary.
- Run tests in slow mode after every code generation to ensure nothing breaks.
- Use pytest markers to distinguish between fast and slow tests.

### 6. **Version Control**
- Use Git for version control. Commit changes with clear, descriptive messages.
- Avoid committing unnecessary files (e.g., logs, cache files, virtual environment).

## Testing Guidelines
- All test files (unit, integration, and functional tests) should be placed in the `tests/` directory.
- Do not place test files in source or script directories.
- This ensures a clean separation between production code and tests, and makes test discovery easier for CI/CD and developers.

## Conclusion
Following these guidelines will help maintain a clean, maintainable, and scalable codebase. If you have any questions or suggestions, please raise them in the project discussions.

# Algorithmic Trading System Architecture

## Core Principles

### 1. Feature Engineering
- All features MUST be generated by the feature engineering store
- Strategies SHOULD NOT generate their own features
- Features should be:
  - Cached for performance
  - Reusable across strategies
  - Consistently calculated
  - Version controlled

### 2. Strategy Design
- Strategies should focus on:
  - Signal generation
  - Decision making
  - Risk management
- Strategies should NOT:
  - Generate features
  - Handle data fetching
  - Manage portfolio state

### 3. Portfolio Management
- Portfolio state is managed by PortfolioManager
- Strategies should not maintain portfolio state
- All trades must go through PortfolioManager

### 4. Trade Execution
- TradeDecider handles all trade decisions
- Strategies provide signals only
- TradeDecider applies constraints and risk management

## Directory Structure
```
src/
├── execution/           # Trade execution and portfolio management
├── features/           # Feature engineering and storage
├── strategies/         # Trading strategies
│   ├── base_strategy.py
│   └── SingleStock/    # Single stock strategies
└── run_trading_system.py
```

## Strategy Interface
All strategies must:
1. Inherit from BaseStrategy
2. Use features from feature store
3. Generate standardized signals
4. Not maintain state (except for model parameters)

## Feature Store Interface
Feature store must:
1. Cache calculated features
2. Provide consistent feature calculation
3. Support feature versioning
4. Handle data preprocessing 