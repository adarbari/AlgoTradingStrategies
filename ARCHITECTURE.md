# Project Architecture and Guidelines

## Overview
This document outlines the structure, architecture, and philosophies of the AlgoTradingModels project. It aims to prevent duplicate files, ensure clear separation of concerns, and maintain a clean, maintainable codebase.

## Project Structure
```
AlgoTradingModels/
├── src/                    # Source code
│   ├── data/              # Data fetching, processing, and caching
│   │   ├── vendors/       # Data providers (Polygon, Yahoo Finance)
│   │   └── data_loader.py # Data loading and caching
│   ├── execution/         # Trade execution and portfolio management
│   │   ├── portfolio_manager.py
│   │   ├── trade_executor.py
│   │   └── signal_aggregation/  # Signal aggregation strategies
│   ├── features/          # Feature engineering
│   │   ├── feature_store.py
│   │   └── technical_indicators.py
│   ├── strategies/        # Trading strategies
│   │   ├── SingleStock/   # Single stock strategies
│   │   └── portfolio/     # Portfolio strategies
│   ├── visualization/     # Results visualization
│   └── run_trading_system.py  # Main system driver
├── tests/                 # Unit and integration tests
├── logs/                  # Logs and results
├── setup.py              # Package setup
└── README.md             # Project documentation
```

## Core Components

### 1. Data Layer
- Responsible for data fetching, processing, and caching
- Supports multiple data providers (Polygon, Yahoo Finance)
- Implements data caching for performance
- Handles data preprocessing and validation

### 2. Feature Layer
- Manages feature engineering and technical indicators
- Implements feature caching through FeatureStore
- Ensures consistent feature calculation across strategies
- Supports feature versioning and validation

### 3. Strategy Layer
- Implements trading strategies (SingleStock and Portfolio)
- Generates trading signals based on features
- Supports multiple strategy types:
  - Moving Average Crossover
  - Random Forest ML-based
  - Portfolio-based strategies

### 4. Execution Layer
- Manages portfolio state and positions
- Handles trade execution and risk management
- Implements signal aggregation for multi-strategy portfolios
- Provides performance metrics and analysis

## Key Philosophies

### 1. Single Responsibility Principle
- Each module or class should have only one reason to change
- Clear separation between data, features, strategies, and execution
- Avoid mixing concerns across layers

### 2. Feature Engineering
- All features MUST be generated by the feature engineering store
- Strategies SHOULD NOT generate their own features
- Features should be:
  - Cached for performance
  - Reusable across strategies
  - Consistently calculated
  - Version controlled

### 3. Strategy Design
- Strategies should focus on:
  - Signal generation
  - Decision making
  - Risk management
- Strategies should NOT:
  - Generate features
  - Handle data fetching
  - Manage portfolio state

### 4. Portfolio Management
- Portfolio state is managed by PortfolioManager
- Strategies should not maintain portfolio state
- All trades must go through PortfolioManager
- Support for multi-strategy portfolios with signal aggregation

### 5. Testing and Documentation
- Write unit tests for all modules and functions
- Document code with clear docstrings and comments
- Use pytest markers for fast/slow tests
- Maintain test coverage above 80%

### 6. Version Control
- Use Git for version control
- Commit changes with clear, descriptive messages
- Follow conventional commit format
- Avoid committing unnecessary files

## Testing Guidelines
- All test files should be placed in the `tests/` directory
- Use pytest for testing
- Mark slow tests with `@pytest.mark.slow`
- Maintain test coverage reports
- Run tests in CI/CD pipeline

## Configuration Guidelines
- Use configuration files for strategy parameters
- Support command-line arguments for runtime configuration
- Use environment variables for sensitive data
- Implement configuration validation

## Performance Guidelines
- Cache expensive computations
- Use efficient data structures
- Implement proper error handling
- Monitor memory usage
- Profile code for bottlenecks

## Service-Oriented Architecture (SOA) Guidelines

### 1. Service Independence
- Each strategy and agent should be designed as a potential standalone service
- Minimize dependencies between components
- Use clean interfaces for inter-service communication
- Design for eventual service extraction

### 2. Interface Design
- Define clear service boundaries
- Use well-documented APIs for inter-service communication
- Implement versioning for service interfaces
- Design interfaces to be technology-agnostic

### 3. Service Components
- **Strategy Services**
  - Single stock trading strategies
  - Portfolio management strategies
  - Signal generation services
  - Each strategy should be independently deployable

- **Data Services**
  - Market data providers
  - Feature engineering services
  - Data caching and storage
  - Historical data management

- **Execution Services**
  - Trade execution
  - Order management
  - Position tracking
  - Risk management

- **Aggregation Services**
  - Signal aggregation
  - Portfolio aggregation
  - Performance metrics aggregation

### 4. Service Communication
- Use message queues for asynchronous communication
- Implement event-driven architecture
- Design for eventual consistency
- Handle service failures gracefully

### 5. Data Management
- Each service should own its data
- Implement data versioning
- Design for data consistency across services
- Use appropriate data storage solutions per service

### 6. Deployment Considerations
- Design for containerization
- Implement health checks
- Use service discovery
- Support horizontal scaling
- Implement circuit breakers

### 7. Service Extraction Strategy
- Identify service boundaries
- Plan for gradual extraction
- Maintain backward compatibility
- Implement feature flags for smooth transition

## Implementation Guidelines for Service Extraction

### 1. Current Implementation
- Keep current monolithic structure
- Design components as if they were services
- Use dependency injection
- Implement interface-based design

### 2. Future Service Extraction
- Plan for service boundaries
- Design for API-first approach
- Implement service discovery
- Prepare for distributed deployment

### 3. Interface Examples
```python
# Strategy Service Interface
class StrategyService:
    def generate_signals(self, data: MarketData) -> List[Signal]:
        pass

    def update_state(self, new_data: MarketData) -> None:
        pass

# Portfolio Service Interface
class PortfolioService:
    def update_positions(self, trades: List[Trade]) -> PortfolioState:
        pass

    def calculate_metrics(self) -> PortfolioMetrics:
        pass

# Signal Aggregation Service Interface
class SignalAggregationService:
    def aggregate_signals(self, signals: List[Signal]) -> AggregatedSignal:
        pass

    def update_weights(self, new_weights: Dict[str, float]) -> None:
        pass
```

### 4. Service Dependencies
- Minimize direct dependencies
- Use dependency injection
- Implement service locator pattern
- Design for loose coupling

### 5. Error Handling
- Implement circuit breakers
- Use retry mechanisms
- Handle partial failures
- Implement fallback strategies

### 6. Monitoring and Logging
- Implement distributed tracing
- Use structured logging
- Monitor service health
- Track performance metrics

## Trade Execution Orchestrator Implementation Phases

### Phase 2: Signal Aggregation (Current)
- **Signal Aggregation Service**
  - Weighted average aggregation
  - Strategy signal combination
  - Portfolio-level signal generation
  - Signal validation and normalization

- **Implementation Details**
  ```python
  class SignalAggregationService:
      def aggregate_signals(self, signals: List[Signal]) -> AggregatedSignal:
          """
          Aggregates signals from multiple strategies using weighted averaging
          """
          pass

      def validate_signals(self, signals: List[Signal]) -> bool:
          """
          Validates signals before aggregation
          """
          pass

      def normalize_weights(self, weights: Dict[str, float]) -> Dict[str, float]:
          """
          Normalizes strategy weights to ensure they sum to 1
          """
          pass
  ```

### Phase 3: Advanced Orchestration (Planned)
- **Risk Management Service**
  - Position sizing
  - Risk limits enforcement
  - Portfolio exposure management
  - Drawdown control

- **Order Management Service**
  - Order routing
  - Execution optimization
  - Smart order routing
  - Order book analysis

- **Portfolio Optimization Service**
  - Dynamic rebalancing
  - Asset allocation
  - Correlation analysis
  - Portfolio constraints

- **Implementation Details**
  ```python
  class RiskManagementService:
      def calculate_position_size(self, signal: Signal, portfolio: Portfolio) -> float:
          """
          Calculates position size based on risk parameters
          """
          pass

      def check_risk_limits(self, trade: Trade) -> bool:
          """
          Validates trade against risk limits
          """
          pass

  class OrderManagementService:
      def optimize_execution(self, order: Order) -> ExecutionStrategy:
          """
          Determines optimal execution strategy
          """
          pass

      def route_order(self, order: Order) -> OrderRoute:
          """
          Routes order to appropriate venue
          """
          pass

  class PortfolioOptimizationService:
      def optimize_allocation(self, portfolio: Portfolio) -> Allocation:
          """
          Optimizes portfolio allocation
          """
          pass

      def rebalance_portfolio(self, portfolio: Portfolio) -> List[Trade]:
          """
          Generates rebalancing trades
          """
          pass
  ```

### Service Integration
- **Event Flow**
  1. Signal Aggregation (Phase 2)
  2. Risk Management (Phase 3)
  3. Portfolio Optimization (Phase 3)
  4. Order Management (Phase 3)
  5. Trade Execution

- **Implementation Example**
  ```python
  class TradeExecutionOrchestrator:
      def __init__(self):
          self.signal_aggregator = SignalAggregationService()
          self.risk_manager = RiskManagementService()
          self.portfolio_optimizer = PortfolioOptimizationService()
          self.order_manager = OrderManagementService()

      async def execute_trades(self, signals: List[Signal], portfolio: Portfolio):
          # Phase 2: Signal Aggregation
          aggregated_signal = self.signal_aggregator.aggregate_signals(signals)
          
          # Phase 3: Risk Management
          position_size = self.risk_manager.calculate_position_size(
              aggregated_signal, portfolio
          )
          
          # Phase 3: Portfolio Optimization
          allocation = self.portfolio_optimizer.optimize_allocation(portfolio)
          
          # Phase 3: Order Management
          orders = self.order_manager.create_orders(
              allocation, position_size, aggregated_signal
          )
          
          # Execute trades
          return await self.execute_orders(orders)
  ```

### Phase 3 Implementation Guidelines
1. **Modular Design**
   - Each service should be independently deployable
   - Use dependency injection for service composition
   - Implement circuit breakers for service resilience

2. **Data Flow**
   - Implement event-driven architecture
   - Use message queues for service communication
   - Maintain data consistency across services

3. **Error Handling**
   - Implement retry mechanisms
   - Use circuit breakers
   - Handle partial failures gracefully
   - Implement fallback strategies

4. **Monitoring**
   - Track service health
   - Monitor performance metrics
   - Implement distributed tracing
   - Log service interactions

## Trade Execution Orchestrator Usage Scenarios

### Core Orchestrator Design Principles
- Keep core orchestration logic scenario-agnostic
- Separate execution environment specifics from core logic
- Use dependency injection for environment-specific components
- Maintain consistent interfaces across all scenarios

### Usage Scenarios

#### 1. Backtesting
- **Purpose**: End-to-end strategy testing and historical performance analysis
- **Key Components**:
  ```python
  class BacktestExecutionEnvironment:
      def __init__(self, historical_data: HistoricalData):
          self.data = historical_data
          self.simulated_portfolio = SimulatedPortfolio()
          
      def execute_trade(self, order: Order) -> TradeResult:
          """
          Simulates trade execution using historical data
          """
          pass
          
      def get_market_data(self, timestamp: datetime) -> MarketData:
          """
          Retrieves historical market data
          """
          pass
  ```

#### 2. Strategy Benchmarking
- **Purpose**: Compare strategy performance against other strategies
- **Key Components**:
  ```python
  class BenchmarkExecutionEnvironment:
      def __init__(self, strategies: List[Strategy]):
          self.strategies = strategies
          self.benchmark_portfolio = BenchmarkPortfolio()
          
      def execute_benchmark(self, timeframe: TimeFrame) -> BenchmarkResults:
          """
          Executes and compares multiple strategies
          """
          pass
          
      def calculate_metrics(self) -> Dict[str, float]:
          """
          Calculates performance metrics for comparison
          """
          pass
  ```

#### 3. Live Trading
- **Purpose**: Real-time strategy execution
- **Key Components**:
  ```python
  class LiveExecutionEnvironment:
      def __init__(self, broker: Broker):
          self.broker = broker
          self.live_portfolio = LivePortfolio()
          
      def execute_trade(self, order: Order) -> TradeResult:
          """
          Executes trades through live broker
          """
          pass
          
      def get_market_data(self) -> MarketData:
          """
          Retrieves real-time market data
          """
          pass
  ```

### Scenario-Agnostic Core Components

#### 1. Trade Execution Orchestrator
```python
class TradeExecutionOrchestrator:
    def __init__(self, execution_environment: ExecutionEnvironment):
        self.environment = execution_environment
        self.signal_aggregator = SignalAggregationService()
        self.risk_manager = RiskManagementService()
        self.portfolio_optimizer = PortfolioOptimizationService()
        self.order_manager = OrderManagementService()

    async def execute_trades(self, signals: List[Signal], portfolio: Portfolio):
        # Core orchestration logic remains the same across scenarios
        aggregated_signal = self.signal_aggregator.aggregate_signals(signals)
        position_size = self.risk_manager.calculate_position_size(
            aggregated_signal, portfolio
        )
        allocation = self.portfolio_optimizer.optimize_allocation(portfolio)
        orders = self.order_manager.create_orders(
            allocation, position_size, aggregated_signal
        )
        
        # Environment-specific execution
        return await self.environment.execute_trade(orders)
```

#### 2. Common Interfaces
```python
class ExecutionEnvironment(ABC):
    @abstractmethod
    def execute_trade(self, order: Order) -> TradeResult:
        pass
        
    @abstractmethod
    def get_market_data(self) -> MarketData:
        pass
        
    @abstractmethod
    def get_portfolio_state(self) -> PortfolioState:
        pass
```

### Implementation Guidelines

#### 1. Core Logic Separation
- Keep all scenario-specific logic in environment classes
- Core orchestrator should only contain business logic
- Use dependency injection for environment-specific components
- Maintain consistent interfaces across all scenarios

#### 2. Data Management
- Use abstract data interfaces
- Implement scenario-specific data providers
- Cache data appropriately for each scenario
- Handle data timing differences between scenarios

#### 3. Error Handling
- Implement scenario-specific error handling
- Use appropriate logging for each scenario
- Handle timing and latency differences
- Implement appropriate retry mechanisms

#### 4. Performance Considerations
- Optimize for each scenario's requirements
- Use appropriate caching strategies
- Handle real-time vs. historical data differences
- Implement appropriate monitoring

### Example Usage

```python
# Backtesting
backtest_env = BacktestExecutionEnvironment(historical_data)
backtest_orchestrator = TradeExecutionOrchestrator(backtest_env)
backtest_results = await backtest_orchestrator.execute_trades(signals, portfolio)

# Benchmarking
benchmark_env = BenchmarkExecutionEnvironment(strategies)
benchmark_orchestrator = TradeExecutionOrchestrator(benchmark_env)
benchmark_results = await benchmark_orchestrator.execute_trades(signals, portfolio)

# Live Trading
live_env = LiveExecutionEnvironment(broker)
live_orchestrator = TradeExecutionOrchestrator(live_env)
live_results = await live_orchestrator.execute_trades(signals, portfolio)
```

## Conclusion
Following these guidelines will help maintain a clean, maintainable, and scalable codebase. If you have any questions or suggestions, please raise them in the project discussions.

# Algorithmic Trading System Architecture

## Core Principles

### 1. Feature Engineering
- All features MUST be generated by the feature engineering store
- Strategies SHOULD NOT generate their own features
- Features should be:
  - Cached for performance
  - Reusable across strategies
  - Consistently calculated
  - Version controlled

### 2. Strategy Design
- Strategies should focus on:
  - Signal generation
  - Decision making
  - Risk management
- Strategies should NOT:
  - Generate features
  - Handle data fetching
  - Manage portfolio state

### 3. Portfolio Management
- Portfolio state is managed by PortfolioManager
- Strategies should not maintain portfolio state
- All trades must go through PortfolioManager

### 4. Trade Execution
- TradeDecider handles all trade decisions
- Strategies provide signals only
- TradeDecider applies constraints and risk management

## Directory Structure
```
src/
├── execution/           # Trade execution and portfolio management
├── features/           # Feature engineering and storage
├── strategies/         # Trading strategies
│   ├── base_strategy.py
│   └── SingleStock/    # Single stock strategies
└── run_trading_system.py  # Main driver file
```

## Strategy Interface
All strategies must:
1. Inherit from BaseStrategy
2. Use features from feature store
3. Generate standardized signals
4. Not maintain state (except for model parameters)

## Feature Store Interface
Feature store must:
1. Cache calculated features
2. Provide consistent feature calculation
3. Support feature versioning
4. Handle data preprocessing 

## Recent Update
- The driver file is now `run_trading_system.py`. 