# Project Architecture and Guidelines

## Overview
This document outlines the structure, architecture, and philosophies of the AlgoTradingModels project. It aims to prevent duplicate files, ensure clear separation of concerns, and maintain a clean, maintainable codebase.

## Project Structure
```
AlgoTradingModels/
├── src/                    # Source code
│   ├── data/              # Data fetching, processing, and caching
│   │   ├── vendors/       # Data providers (Polygon, Yahoo Finance)
│   │   └── data_loader.py # Data loading and caching
│   ├── execution/         # Trade execution and portfolio management
│   │   ├── portfolio_manager.py
│   │   ├── trade_executor.py
│   │   └── signal_aggregation/  # Signal aggregation strategies
│   ├── features/          # Feature engineering
│   │   ├── feature_store.py
│   │   └── technical_indicators.py
│   ├── strategies/        # Trading strategies
│   │   ├── SingleStock/   # Single stock strategies
│   │   └── portfolio/     # Portfolio strategies
│   ├── visualization/     # Results visualization
│   └── run_trading_system.py  # Main system driver
├── tests/                 # Unit and integration tests
├── logs/                  # Logs and results
├── setup.py              # Package setup
└── README.md             # Project documentation
```

## Core Components

### 1. Data Layer
- Responsible for data fetching, processing, and caching
- Supports multiple data providers (Polygon, Yahoo Finance)
- Implements data caching for performance
- Handles data preprocessing and validation

### 2. Feature Layer
- Manages feature engineering and technical indicators
- Implements feature caching through FeatureStore
- Ensures consistent feature calculation across strategies
- Supports feature versioning and validation

### 3. Strategy Layer
- Implements trading strategies (SingleStock and Portfolio)
- Generates trading signals based on features
- Supports multiple strategy types:
  - Moving Average Crossover
  - Random Forest ML-based
  - Portfolio-based strategies

### 4. Execution Layer
- Manages portfolio state and positions
- Handles trade execution and risk management
- Implements signal aggregation for multi-strategy portfolios
- Provides performance metrics and analysis

## Key Philosophies

### 1. Single Responsibility Principle
- Each module or class should have only one reason to change
- Clear separation between data, features, strategies, and execution
- Avoid mixing concerns across layers

### 2. Feature Engineering
- All features MUST be generated by the feature engineering store
- Strategies SHOULD NOT generate their own features
- Features should be:
  - Cached for performance
  - Reusable across strategies
  - Consistently calculated
  - Version controlled

### 3. Strategy Design
- Strategies should focus on:
  - Signal generation
  - Decision making
  - Risk management
- Strategies should NOT:
  - Generate features
  - Handle data fetching
  - Manage portfolio state

### 4. Portfolio Management
- Portfolio state is managed by PortfolioManager
- Strategies should not maintain portfolio state
- All trades must go through PortfolioManager
- Support for multi-strategy portfolios with signal aggregation

### 5. Testing and Documentation
- Write unit tests for all modules and functions
- Document code with clear docstrings and comments
- Use pytest markers for fast/slow tests
- Maintain test coverage above 80%

### 6. Version Control
- Use Git for version control
- Commit changes with clear, descriptive messages
- Follow conventional commit format
- Avoid committing unnecessary files

## Testing Guidelines
- All test files should be placed in the `tests/` directory
- Use pytest for testing
- Mark slow tests with `@pytest.mark.slow`
- Maintain test coverage reports
- Run tests in CI/CD pipeline

## Configuration Guidelines
- Use configuration files for strategy parameters
- Support command-line arguments for runtime configuration
- Use environment variables for sensitive data
- Implement configuration validation

## Performance Guidelines
- Cache expensive computations
- Use efficient data structures
- Implement proper error handling
- Monitor memory usage
- Profile code for bottlenecks

## Conclusion
Following these guidelines will help maintain a clean, maintainable, and scalable codebase. If you have any questions or suggestions, please raise them in the project discussions.

# Algorithmic Trading System Architecture

## Core Principles

### 1. Feature Engineering
- All features MUST be generated by the feature engineering store
- Strategies SHOULD NOT generate their own features
- Features should be:
  - Cached for performance
  - Reusable across strategies
  - Consistently calculated
  - Version controlled

### 2. Strategy Design
- Strategies should focus on:
  - Signal generation
  - Decision making
  - Risk management
- Strategies should NOT:
  - Generate features
  - Handle data fetching
  - Manage portfolio state

### 3. Portfolio Management
- Portfolio state is managed by PortfolioManager
- Strategies should not maintain portfolio state
- All trades must go through PortfolioManager

### 4. Trade Execution
- TradeDecider handles all trade decisions
- Strategies provide signals only
- TradeDecider applies constraints and risk management

## Directory Structure
```
src/
├── execution/           # Trade execution and portfolio management
├── features/           # Feature engineering and storage
├── strategies/         # Trading strategies
│   ├── base_strategy.py
│   └── SingleStock/    # Single stock strategies
└── run_trading_system.py  # Main driver file
```

## Strategy Interface
All strategies must:
1. Inherit from BaseStrategy
2. Use features from feature store
3. Generate standardized signals
4. Not maintain state (except for model parameters)

## Feature Store Interface
Feature store must:
1. Cache calculated features
2. Provide consistent feature calculation
3. Support feature versioning
4. Handle data preprocessing 

## Recent Update
- The driver file is now `run_trading_system.py`. 